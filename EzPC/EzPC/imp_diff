diff --git a/EzPC/EzPC/ABY_example/common/ezpc.h b/EzPC/EzPC/ABY_example/common/ezpc.h
index 6f55640..f00fcc5 100644
--- a/EzPC/EzPC/ABY_example/common/ezpc.h
+++ b/EzPC/EzPC/ABY_example/common/ezpc.h
@@ -36,6 +36,11 @@ SOFTWARE.
 #include<cmath>
 using namespace std;
 
+share* put_flt_cons32_gate(Circuit* c, float val, uint32_t bitlen, e_role role){
+  assert(c->GetCircuitType() == C_BOOLEAN);
+  uint32_t* val_int = (uint32_t*)&val;
+  return ((BooleanCircuit*)c)->PutINGate(val_int, bitlen, SERVER);
+}
 /*
  * somehow we need this redirection for adding Cons gates
  * directly calling PutConsGate gives an error
@@ -113,7 +118,7 @@ share* arithmetic_right_shift(Circuit* c, share* val, uint32_t shift_factor) {
 struct output_queue_elmt {
   ostream& os;  //output stream to which we will output (cout or files), can this be a reference to prevent copying?
   e_role role;  //who should we output the clear value to
-  enum {PrintMsg, PrintValue } kind;
+  enum {PrintMsg, PrintValue, PrintFloatValue } kind;
   string msg;
   share *ptr;
 };
@@ -131,6 +136,18 @@ void add_to_output_queue(output_queue &q,
   q.push_back(elmt);
 }
 
+/*
+ * called from the EzPC generated code
+ */
+void add_float_to_output_queue(output_queue &q,
+			 share *ptr,
+			 e_role role,
+			 ostream &os)
+{
+  struct output_queue_elmt elmt { os, role, output_queue_elmt::PrintFloatValue, "", ptr };
+  q.push_back(elmt);
+}
+
 void add_print_msg_to_output_queue (output_queue &q, string msg, e_role role, ostream &os)
 {
   struct output_queue_elmt elmt { os, role, output_queue_elmt::PrintMsg, msg, NULL };
@@ -153,7 +170,20 @@ void flush_output_queue(output_queue &q, e_role role, uint32_t bitlen)
           it->os << it->ptr->get_clear_value<uint64_t>() << endl;
         }
       }
-    } else {
+    } else if (it->kind == output_queue_elmt::PrintFloatValue){
+      if(it->role == ALL || it->role == role) {  //if the queue element role is same as mine
+        if(bitlen == 32) {  //output to the stream
+          uint32_t out_int_val = it->ptr->get_clear_value<uint32_t>() ;
+          float out_val = *((float*)&out_int_val);
+          it->os << out_val << endl;
+        } else {
+          uint64_t out_int_val = it->ptr->get_clear_value<uint64_t>() ;
+          double out_val = *((double*)&out_int_val);
+          it->os << out_val << endl;
+        }
+      }
+    }
+    else{
       if(it->role == ALL || it->role == role) {  //if the queue element role is same as mine
         it->os << it->msg << endl;
       }

diff --git a/EzPC/EzPC/codegen.ml b/EzPC/EzPC/codegen.ml
index 5b66636..3e7655d 100644
--- a/EzPC/EzPC/codegen.ml
+++ b/EzPC/EzPC/codegen.ml

 let o_cbfunction :secret_label -> comp -> comp list -> comp = o_cbfunction_maybe_coerce false
 
+let o_flt_app (head:comp) (op_s: comp) (args:comp list) :comp = 
+  o_hd_and_args head (args @ [  (op_s);  ( o_str "bitlen");  (o_str "1");  (o_str "no_status")])
+
+let o_fltunfunction (l:secret_label) (s_op: comp) (args: comp list): comp = 
+  o_flt_app (seq (o_slabel_maybe_coerce true Boolean)  (o_str "->PutFPGate") ) s_op args
+
 let o_sunop (l:secret_label) (op:unop) (c:comp) :comp =
-  let c_op =
+  let aux (arg: comp) = o_cbfunction_maybe_coerce true l arg [c] in
+  let float_aux_unop (op_s:string): comp = o_fltunfunction l (o_str op_s)  [c] in
     match op with
     | U_minus -> failwith "Codegen: unary minus is not being produced by lexer or parser right now."
     | Bitwise_neg 
-    | Not -> o_str "PutINVGate"
-  in
-  o_cbfunction_maybe_coerce true l c_op [c]
+    | Not ->  aux (o_str "PutINVGate")
+    | Float_exp -> float_aux_unop "EXP"
+    | Float_exp2 -> float_aux_unop "EXP2"
   
+let o_fltfunction (l:secret_label) (s_op: comp) (args: comp list): comp = 
+  o_flt_app (seq (o_slabel_maybe_coerce true Boolean)  (o_str "->PutFPGate") ) s_op args
+
 let o_sbinop (l:secret_label) (op:binop) (c1:comp) (c2:comp) :comp =
   let aux (s:string) (coerce:bool) :comp = o_cbfunction_maybe_coerce coerce l (o_str s) [c1; c2] in
+  let float_aux (op_s:string): comp = o_fltfunction l (o_str op_s)  [c1; c2] in 
   let err (s:string) = failwith ("Operator: " ^ s ^ " should have been desugared") in
   match op with
   | Sum                -> aux "PutADDGate" false
   | Sub                -> aux "PutSUBGate" false
   | Mul                -> aux "PutMULGate" false
   | Greater_than       -> aux "PutGTGate" false
+  | Float_sum          -> float_aux "ADD" 
+  | Float_sub          -> float_aux "SUB" 
+  | Float_mul          -> float_aux "MUL" 
+  | Float_div          -> float_aux "DIV" 
   | Div                -> err "DIV"
   | Mod                -> err "MOD"
   | Less_than          -> err "LT"
@@ -137,18 +158,20 @@ let o_pconditional (c1:comp) (c2:comp) (c3:comp) :comp =
 let o_sconditional (l:secret_label) (c_cond:comp) (c_then:comp) (c_else:comp) :comp =
   o_cbfunction l (o_str "PutMUXGate") [c_then; c_else; c_cond]
 
+let o_flt_subsumption (gate: comp) (args: comp list): comp = 
+  o_app gate (args @ [(o_str "bitlen"); (o_str "role")])
+
 let o_subsumption (src:label) (tgt:secret_label) (t:typ) (arg:comp) :comp =
   match src with
     | Public -> 
-       let fn =
-         o_str (
-             match t.data with
-             | Base (UInt32, _) | Base (Int32, _) -> "put_cons32_gate"
-             | Base (UInt64, _) | Base (Int64, _) -> "put_cons64_gate"
-             | Base (Bool, _) -> "put_cons1_gate"
-             | _ -> failwith ("codegen:Subsumption node with an unexpected typ: " ^ (typ_to_string t)))
-       in
-       o_app fn [o_slabel tgt; arg]
+       (let aux (s:string) : comp = o_app (o_str s) [o_slabel tgt; arg] in
+       (let flt_aux (s:string): comp = o_flt_subsumption (o_str s) [o_slabel_maybe_coerce true tgt; arg] in
+          match t.data with
+          | Base (UInt32, _) | Base (Int32, _) -> aux "put_cons32_gate"
+          | Base (UInt64, _) | Base (Int64, _) -> aux "put_cons64_gate"
+          | Base (Bool, _) -> aux "put_cons1_gate"
+          | Base (Float32,_) -> flt_aux "put_flt_cons32_gate"
+          | _ -> failwith ("codegen:Subsumption node with an unexpected typ: " ^ (typ_to_string t))))
     | Secret Arithmetic ->
        let fn_name = if Config.get_bool_sharing_mode () = Config.Yao then "PutA2YGate" else "PutA2BGate" in
        o_cbfunction tgt (o_str fn_name) [arg]
@@ -165,6 +188,7 @@ let o_basetyp (t:base_type) :comp =
   | UInt64 -> o_str "uint64_t"
   | Int32  -> o_str "int32_t"
   | Int64  -> o_str "int64_t"
+  | Float32 -> o_str "float"
   | Bool   -> o_str "uint32_t"
 